# -*- coding: utf-8 -*-
"""
/***************************************************************************
 EDGVConverter
                                 A QGIS plugin
 aaa
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-07-23
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Brazilian Army
        email                : bryan.andrade.ime@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtGui import *
from PyQt5.QtWidgets import QFileDialog, QMessageBox
from PyQt5 import QtGui
from PyQt5 import QtWidgets
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .EDGV_Converter_dialog import EDGVConverterDialog
from .EDGV_Converter_dialog import AtributosDialog
from .EDGV_Converter_dialog import DominioDialog
import os.path
import psycopg2
import psycopg2.extras
import json
import pandas as pd
import ctypes  # An included library with Python install.   


# lemos o JSON em disco
#with open('TESTEE.txt','w') as json_file:
#json_file = open('TESTEE.txt','w')
#json_file = open('C:\\Users\\bryan\\Desktop\IME\\PFC\\A.txt','w')
#lista_classes = json.loads(conteudo)


class EDGVConverter:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'EDGVConverter_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&EDGV Converter')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        
        #Chama o janela
        self.dlg2 = AtributosDialog()
        self.dlg3 = DominioDialog()
        
        #Cria listas auxiliares
        self.list2 = []
        self.list1 = []
        self.list = []
        self.listaClasse213=[]
        self.listaClasse30=[]
        self.ldomClasse213=[]
        self.ldomClasse30=[]
        self.ldomValor213=[]
        self.ldomValor30=[]
        self.contador=0
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('EDGVConverter', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/EDGV_Converter/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'teste'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&EDGV Converter'),
                action)
            self.iface.removeToolBarIcon(action)
            
    def fCriaConexao(self,db,strQuery):
        connection = psycopg2.connect(user = self.dlg.txtLogin.text(), password = self.dlg.txtPass.text(), host = self.dlg.txtHost.text(), database = db)
        cursor = connection.cursor()
        cursor.execute(strQuery)
        record = cursor.fetchall()
        cursor.close()
        listaDB = []
        for item in record:
            b = item
            c = ''.join(item)
            listaDB.append(c)
            
        fCriaConexao = listaDB
        return fCriaConexao
        
    def fCriaConexaoTB(self,db,strQuery):
        connection = psycopg2.connect(user = self.dlg.txtLogin.text(), password = self.dlg.txtPass.text(), host = self.dlg.txtHost.text(), database = db)
        cursor = connection.cursor()
        cursor.execute(strQuery)
        record = cursor.fetchall()
        cursor.close()
        fCriaConexaoTB = record
        return fCriaConexaoTB
        
    def msgbtn(self):
        QMessageBox.close()
        
    def fTestaPostgreSQL_Conexao(self,usu,pw,hs,db):

        try:
            conn = psycopg2.connect(user = usu, password = pw, host = hs, database = db, connect_timeout=0.1)
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Information)
            msg.setText("Conectado!")
            msg.setWindowTitle("Sucesso!")
            msg.setStandardButtons(QMessageBox.Ok)
            msg.show()
            #msg.buttonClicked.connect(msgbtn)
            #QMessageBox.about(self, "Title", "Message")
            #ctypes.windll.user32.MessageBoxW(0, 'Conectado!', 1)
            #return True
            self.dlg.txtLog.appendPlainText('Conexão bem sucedida\n')
            conn.close()
        except:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Critical)
            msg.setText("Checar dados de conexao!!")
            msg.setWindowTitle("Erro!")
            msg.setStandardButtons(QMessageBox.Ok)
            self.dlg.txtLog.appendPlainText('Conexão falhou:\nChecar dados de conexao!!')
            msg.show()
            #ctypes.windll.user32.MessageBoxW(0, 'Checar dados de conexao!', 1)
            #return False
    

    
    def fPopulaBase(self):
        self.dlg.cmbBaseOrigem.clear()
        self.dlg.cmbBaseDestino.clear()
        
        listaDB = []
        listaDB = self.fCriaConexao("postgres","SELECT datname FROM pg_database ;")
            
        for i in listaDB:
            self.dlg.cmbBaseOrigem.addItem(i)
            self.dlg.cmbBaseDestino.addItem(i)

    def fPopulaClasseOrigem(self,db):
        self.dlg.lstClasseOrigem.clear()

        listaTB = []
        listaTB = self.fCriaConexao(db,"SELECT concat_ws('.', table_schema, information_schema.tables.table_name) from information_schema.tables inner join pg_class on pg_class.relname = information_schema.tables.table_name where relkind = 'r' and relname !~ '^(pg_|sql_)' and table_schema <> 'dominios' order by relname ;")

        for i in listaTB:
            self.dlg.lstClasseOrigem.addItem(i)
        #return listaTB
            
    def fPopulaClasseDestino(self,db):
        self.dlg.lstClasseDestino.clear()
        
        listaTB = []
        listaTB = self.fCriaConexao(db,"SELECT concat_ws('.', table_schema, information_schema.tables.table_name) from information_schema.tables inner join pg_class on pg_class.relname = information_schema.tables.table_name where relkind = 'r' and relname !~ '^(pg_|sql_)' and table_schema <> 'dominios' order by relname ;")

        for i in listaTB:
            self.dlg.lstClasseDestino.addItem(i)
        #return listaTB
    
    def on_btnRelacionar2_click(self):
        list=[]
        list2=[]
        self.dlg.txtLog.appendPlainText('Mapeamento de dominio registrado: '+str(self.ldomClasse213[0])+'->'+str(self.ldomClasse30[0]))
        list.append(self.dlg3.tbIDOrigem.selectedItems()[0].text())
        list2.append(self.dlg3.tbIDDestino.selectedItems()[0].text())
        self.ldomValor213=list
        self.ldomValor30=list2
        self.fGeraDicionario('LDOM-A')
    def fPopulaDominioOrigem(self,db):
        self.dlg.lstDominioOrigem.clear()

        listaTB = []
        listaTB = self.fCriaConexao(db,"SELECT concat_ws('.', table_schema, information_schema.tables.table_name) from information_schema.tables inner join pg_class on pg_class.relname = information_schema.tables.table_name where relkind = 'r' and relname !~ '^(pg_|sql_)' and table_schema = 'dominios' order by relname ;")

        for i in listaTB:
            self.dlg.lstDominioOrigem.addItem(i)
            
    def fPopulaDominioDestino(self,db):
        self.dlg.lstDominioDestino.clear()
        
        listaTB = []
        listaTB = self.fCriaConexao(db,"SELECT concat_ws('.', table_schema, information_schema.tables.table_name) from information_schema.tables inner join pg_class on pg_class.relname = information_schema.tables.table_name where relkind = 'r' and relname !~ '^(pg_|sql_)' and table_schema = 'dominios' order by relname ;")

        for i in listaTB:
            self.dlg.lstDominioDestino.addItem(i)
            
    def fPopulaAtributoOrigem(self,db,table):
        self.dlg2.lstAtributoOrigem.clear()
        
        listaTB = []
        listaTB = self.fCriaConexao(db,"select column_name from information_schema.columns where concat_ws('.', table_schema, table_name) = '" + table + "' order by column_name ;")
        for i in listaTB:
            self.dlg2.lstAtributoOrigem.addItem(i)
        return listaTB     
    def fPopulaAtributoDestino(self,db,table):
        self.dlg2.lstAtributoDestino.clear()
        
        listaTB = []
        listaTB = self.fCriaConexao(db,"select column_name from information_schema.columns where concat_ws('.', table_schema, table_name) = '" + table + "' order by column_name ;")
        for i in listaTB:
            self.dlg2.lstAtributoDestino.addItem(i)
        return listaTB
    def fPopulaIDOrigem(self,db,table):
        self.dlg3.tbIDOrigem.clear()
        
        listaTB = []
        listaTB = self.fCriaConexaoTB(db,"select code,code_name from " + table + " order by code ;")
        
        """
        for i in listaTB:
            self.dlg2.lstAtributoDestino.addItem(i)
        """
        
        nb_row = len(listaTB)
        nb_col = 2

        self.dlg3.tbIDOrigem.setRowCount(nb_row)
        self.dlg3.tbIDOrigem.setColumnCount(nb_col)

        for row in range (nb_row):
            for col in range(nb_col):
                item = QtWidgets.QTableWidgetItem(str(listaTB[row][col]))
                self.dlg3.tbIDOrigem.setItem(row,col,item)

        self.dlg3.tbIDOrigem.setHorizontalHeaderLabels([u'code',u'code_name'])
        self.dlg3.tbIDOrigem.resizeColumnsToContents()
        
    def fPopulaIDDestino(self,db,table):
        self.dlg3.tbIDDestino.clear()
        
        listaTB = []
        listaTB = self.fCriaConexaoTB(db,"select code,code_name from " + table + " order by code ;")
        
        """
        for i in listaTB:
            self.dlg2.lstAtributoDestino.addItem(i)
        """
        
        nb_row = len(listaTB)
        nb_col = 2

        self.dlg3.tbIDDestino.setRowCount(nb_row)
        self.dlg3.tbIDDestino.setColumnCount(nb_col)

        for row in range (nb_row):
            for col in range(nb_col):
                item = QtWidgets.QTableWidgetItem(str(listaTB[row][col]))
                self.dlg3.tbIDDestino.setItem(row,col,item)

        self.dlg3.tbIDDestino.setHorizontalHeaderLabels([u'code',u'code_name'])
        self.dlg3.tbIDDestino.resizeColumnsToContents()
            
    def on_cmbBaseOrigem_change(self):
        
        self.fPopulaClasseOrigem(str(self.dlg.cmbBaseOrigem.currentText()))
        self.fPopulaDominioOrigem(str(self.dlg.cmbBaseOrigem.currentText()))
      
    def on_cmbBaseDestino_change(self):
        
        self.fPopulaClasseDestino(str(self.dlg.cmbBaseDestino.currentText()))
        self.fPopulaDominioDestino(str(self.dlg.cmbBaseDestino.currentText()))
    
    def on_btnAtributosClasse_click(self):
        #ao mesmo tempo carregamos as listas
        self.list=[]
        self.list1=[]
        self.list2=[]
        self.list = self.fPopulaAtributoOrigem(str(self.dlg.cmbBaseOrigem.currentText()),str(self.dlg.lstClasseOrigem.selectedIndexes()[0].data()))
        self.list1 = self.fPopulaAtributoDestino(str(self.dlg.cmbBaseDestino.currentText()),str(self.dlg.lstClasseDestino.selectedIndexes()[0].data()))        
        self.listaClasse213.clear()
        self.listaClasse213.append(str(self.dlg.lstClasseOrigem.selectedItems()[0].text()))
        self.listaClasse30.clear()
        self.listaClasse30.append(str(self.dlg.lstClasseDestino.selectedItems()[0].text()))
        list3=[]
        list4=[]
        a=(str(self.dlg.lstClasseOrigem.selectedIndexes()[0].data()))
        path=os.path.dirname(os.path.realpath(__file__))+'\\temp\\LISTA\\arqLST_'+a+'.json'
        arq=(str('\\arqLST_'+a+'.json'))
        b=fVerificaCaminho('LISTA',arq)
        if fVerificaCaminho('LISTA',arq):
            with open(path, "r") as read_file:
                data = json.load(read_file)
            for p in data['Par_Colunas']:
                self.list2.append([p['Coluna_Origem'],p['Coluna_Destino']]) 
            for i in self.list2:
                list3.append(self.list.index(i[0]))
                list4.append(self.list1.index(i[1]))
            aux=0
            for i in self.list2:
                selItemsOrigem=self.dlg2.lstAtributoOrigem.item(int(list3[aux]))
                selItemsDestino = self.dlg2.lstAtributoDestino.item(int(list4[aux]))
                oldItemOrigem = selItemsOrigem.text()
                oldItemDestino = selItemsDestino.text()
                selItemsOrigem.setText(oldItemOrigem + ' -> ' + oldItemDestino)
                selItemsDestino.setText(oldItemOrigem + ' -> ' + oldItemDestino)
                self.dlg.txtLog.appendPlainText('Mapeamento de atributo registrado:\n'+oldItemOrigem + ' -> ' + oldItemDestino+'\n')
                aux=aux+1
            aux=0
        else:
            self.dlg.txtLog.appendPlainText('Arquivo da classe:' + str(self.dlg.lstClasseOrigem.selectedIndexes()[0].data()) + ' não encontrado! Favor verificar.')
        self.fGeraDicionario('LISTA')
        self.dlg.exec_()
        self.dlg2.exec_()
        
    def on_btnAtributosDominio_click(self):
        #ao mesmo tempo carregamos as listas
        if len(self.dlg.lstDominioOrigem.selectedIndexes()) != 0:
            self.fPopulaIDOrigem(str(self.dlg.cmbBaseOrigem.currentText()),str(self.dlg.lstDominioOrigem.selectedIndexes()[0].data()))
            self.ldomClasse213.clear()
            self.ldomClasse213.append(str(str(self.dlg.lstDominioOrigem.selectedItems()[0].text())))                 
        if len(self.dlg.lstDominioDestino.selectedIndexes()) != 0:
            self.fPopulaIDDestino(str(self.dlg.cmbBaseDestino.currentText()),str(self.dlg.lstDominioDestino.selectedIndexes()[0].data()))
            self.ldomClasse30.clear()
            self.ldomClasse30.append(str(str(self.dlg.lstDominioDestino.selectedItems()[0].text()))) 
        
        self.fGeraDicionario('LDOM')
        self.dlg3.exec_()
        
    def on_btnRelacionar_click(self):
        selItemsOrigem = self.dlg2.lstAtributoOrigem.selectedItems()[0]
        selItemsDestino = self.dlg2.lstAtributoDestino.selectedItems()[0]
        oldItemOrigem = selItemsOrigem.text()
        oldItemDestino = selItemsDestino.text()
        selItemsOrigem.setText(oldItemOrigem + ' -> ' + oldItemDestino)
        selItemsDestino.setText(oldItemOrigem + ' -> ' + oldItemDestino)
        self.dlg.txtLog.appendPlainText('Mapeamento de classe registrado:\n'+oldItemOrigem + ' -> ' + oldItemDestino+'\n')

    def on_btnCancel1_click(self):
        self.dlg2.close()
        
    def on_btnCancel2_click(self):
        self.dlg3.close()
        
    def on_btnRemover_click(self):
        selItemsOrigem = self.dlg2.lstAtributoOrigem.selectedItems()[0]
        oldItemOrigem = selItemsOrigem.text()
        varItems = oldItemOrigem.split(' -> ')

        oldItemOrigem = varItems[0]
        oldItemDestino = varItems[1]
        selItemsOrigem.setText(oldItemOrigem)
        #selItemsOrigem.setText(oldItemOrigem)
        
        for i in range(self.dlg2.lstAtributoDestino.count()):
            itemDestino = self.dlg2.lstAtributoDestino.item(i).data(0)
            #ctypes.windll.user32.MessageBoxW(0, str(itemDestino), 1)
            #ctypes.windll.user32.MessageBoxW(0, str(oldItemOrigem + ' -> ' + oldItemDestino), 1)
            if itemDestino == oldItemOrigem + ' -> ' + oldItemDestino:
                self.dlg.txtLog.appendPlainText('Mapeamento de atributo removido:\n'+oldItemOrigem + ' -> ' + oldItemDestino+'\n')
                #ctypes.windll.user32.MessageBoxW(0, str(i), 1)
                self.dlg2.lstAtributoDestino.item(i).setText(str(oldItemDestino))
                #ctypes.windll.user32.MessageBoxW(0, str(i), 1)
            #i = i + 1
          
        #ctypes.windll.user32.MessageBoxW(0, str(i), 1)
        
    def on_btnTesteConexao_click(self):
        self.fTestaPostgreSQL_Conexao(self.dlg.txtLogin.text(),self.dlg.txtPass.text(),self.dlg.txtHost.text(),'postgres')

    def on_btnRun_click(self):
        self.fExecutamapeamento()
        
    def on_btnSair_click(self):
        self.dlg.close()
        
            
        #self.dlg.lstClasseOrigem.selectedIndexes()[0].data()
        
        #ctypes.windll.user32.MessageBoxW(0, str(self.dlg.lstClasseOrigem.selectedIndexes()[0].data()), 1)

    def fGeraDicionario(self,tipo):
        self.contador = 0
        if tipo == "LISTA":
           
           data = {}
           data['Par_Classes'] = []
           i=0
           for p in self.listaClasse213:
                #print (self.contador)
                data['Par_Classes'].append({
                    'Classe_Origem': str(self.listaClasse213[i]),
                    'Classe_Destino': str(self.listaClasse30[i])
                })
                i=i+1
           with open(str(os.path.dirname(os.path.realpath(__file__)))+'//temp//'+"arq_selected.json","a") as outfile:
               json.dump(data, outfile)
               
        if tipo=='LDOM':
           data = {}
           data['Par_Colunas'] = []
           c=self.contador
           i=0
           for p in self.ldomClasse213:
                data['Par_Colunas'].append({
                    'Coluna_Origem': str(self.ldomClasse213[i]),
                    'Coluna_Destino': str(self.ldomClasse30[i])
                })
                i=i+1
           with open(str(os.path.dirname(os.path.realpath(__file__)))+'//temp//'+"arq_selected.json","a") as outfile:
               json.dump(data, outfile)
        if tipo=='LDOM-A':   
           i=0      
           data = {}
           data['Valor_Colunas'] = []
           for p in self.ldomValor213:    
                data['Valor_Colunas'].append({
                    'Valor_Origem': str(self.ldomValor213[i]),
                    'Valor_Destino': str(self.ldomValor30[i])
                })
                self.contador = self.contador + 1
                i=i+1
           with open(str(os.path.dirname(os.path.realpath(__file__)))+'//temp//'+"arq_selected.json","a") as outfile:
               json.dump(data, outfile)

    def fExecutamapeamento(self):
        items = []
        for index in range(self.dlg.lstClasseOrigem.count()):
                #print(str(self.dlg.lstClasseOrigem.item(index).data(0)))
                if fProcuraCorrespClasse(self.dlg.lstClasseOrigem.item(index).data(0))!='':
                    items.append(str(self.dlg.lstClasseOrigem.item(index).data(0)))     
        res = [] 
        c=0
        for i in items:  
            a='%s'%str(i)
            ARQ='arqLST_'+a+'.json'
            path=os.path.dirname(os.path.realpath(__file__))+'\\temp\\LISTA\\'+ARQ
            if fVerificaCaminho('LISTA',ARQ)==False:
                continue
            #print(ARQ)
            with open(path, "r") as json_data23:
                json_data2 =  json.load(json_data23)        
            json_ClSSES=''

            cols_teste = ""
            k = 0
            for item in json_data2['Par_Colunas']:
                if item['Coluna_Origem'] != "id":
                    if item['Coluna_Origem'] == "geom":
                        item['Coluna_Origem'] = "CONCAT('$ASPAS$',ST_AsEWKT(geom),'$ASPAS$')"
                        
                    if k == 0:
                        cols_teste = item['Coluna_Origem']
                        k = k +1
                    else:
                        cols_teste = cols_teste + "," + item['Coluna_Origem']
                        k = k +1

            strClasseOrigem=a
            strQueryTest = "SELECT " + cols_teste + " FROM " + strClasseOrigem

            query = strQueryTest

            connection = psycopg2.connect(user = "postgres", password = "123456", host = "127.0.0.1", database = "db_213")
            SQL_Query = pd.read_sql_query(query, connection)

            df = pd.DataFrame(SQL_Query)

            colunas = list(df.columns.values)
            colunas2 = colunas
            #
            #
            for i in range(len(colunas)):
                    if fProcuraDicionario(json_data2,"COLUNA_IDA",colunas2[i],"") == "":
                        del df[colunas[i]]
                    colunas2[i] = fProcuraDicionario(json_data2,"COLUNA_IDA",colunas2[i],"")
            #
            colunas = list(df.columns.values)
            colunas2 = list(filter(None, colunas2))
            #
            ##NO SELECT PRA MONTAR O DATAFRAME TEM Q FAZER COM ST_WK NA COLUNA GEOM E SEM O ID, JA PODER SAIR O DADO CERTO DO INSERT DEPOIS!
            ##Query
            for i in range(len(colunas2)):
                if i == 0:
                    cols_new = colunas2[0]
                else:
                    cols_new = cols_new + "," + str(colunas2[i])

            connection2 = psycopg2.connect(user = "postgres", password = "123456", host = "127.0.0.1", database = "db_3")
            cursor2 = connection2.cursor()

            arq = "arqLST_" + strClasseOrigem + ".json"
            #print(arq)
            cols_new = cols_new + ",geom"
            strValores = ""
            print(df.shape[0],df.shape[1])
            for line in range(df.shape[0]): 
                for col in range(df.shape[1]):
                    #print(type(df.iloc[line,col]))
                    e=fProcuraCorrespClasse(a)
                    b='%s'%(e)
                    strDataTypeQuery = "SELECT udt_name::regtype FROM information_schema.columns WHERE table_schema NOT IN ('information_schema','pg_catalog') AND concat_ws('.', table_schema, table_name) = '%s' AND column_name = '"%(b) + df.columns.values[col] + "'"
                    cursor2.execute(strDataTypeQuery)
                    strDataType = str(cursor2.fetchall())
                    #print (strDataType)
                    arq_LDOM = "arqLST_DOM_" + df.columns.values[col] + ".json"
                    print(arq_LDOM)
                    path=os.path.dirname(os.path.realpath(__file__))+'\\temp\\LDOM\\'+arq_LDOM
                    try:
                        with open(path, "r") as json_ldom:
                            arqLDOM =  json.load(json_ldom)
                    except:
                        pass
                    #cursor2.close()
                    if col == 0:
                        if df.iloc[line,col] is not None:    
                            if is_number(df.iloc[line,col]):
                                if str(strDataType).find("[]")!=-1:
                                    if fProcuraDicionario(arqLDOM,"LISTA_DOM",fProcuraDicionario(arq,"COLUNA_VOLTA",df.columns.values[col],""),str(df.iloc[line,col])) == str(df.iloc[line,col]):
                                        strValores = "'{" + str(df.iloc[line,col]) + "'}"
                                    else:
                                        strValores = "'{" + str(fProcuraDicionario(arqLDOM,"LISTA_DOM",fProcuraDicionario(arq,"COLUNA_VOLTA",df.columns.values[col],""),str(df.iloc[line,col]))) + "'}"
                                else:
                                    strValores = str(df.iloc[line,col])
                            else:
                                strValores = "'" + str(df.iloc[line,col]) + "'"
                        else:
                            strValores = "null"
                    
                    else:
                        if df.iloc[line,col] is not None:
                            if is_number(df.iloc[line,col]):
                                if str(strDataType).find("[]")!=-1:
                                    if fProcuraDicionario(arqLDOM,"LISTA_DOM",fProcuraDicionario(arq,"COLUNA_VOLTA",df.columns.values[col],""),str(df.iloc[line,col])) == str(df.iloc[line,col]):

                                        strValores = strValores + ",'{" + str(df.iloc[line,col]) + "}'"
                                    else:
                                        
                                        strValores = strValores + ",'{" + str(fProcuraDicionario(arqLDOM,"LISTA_DOM",fProcuraDicionario(arq,"COLUNA_VOLTA",df.columns.values[col],""),str(df.iloc[line,col]))) + "}'"
                                else:
                                    strValores = strValores + "," + str(df.iloc[line,col])
                            else:
                                strValores = strValores + ",'" + str(df.iloc[line,col]) + "'"
                        else:
                            strValores = strValores + ",null"
                        
                       
                strQueryFinal = "INSERT INTO " + strClasseDestino + " ("+ cols_new +") VALUES("+ strValores +")"
                strQueryFinal = strQueryFinal.replace("$ASPAS$","")
                cursor2.execute(strQueryFinal)
                print(i)
                #print (strQueryFinal)
                strValores = ""
                
            connection2.commit()
            cursor2.close()
            connection2.close()
        c=c+1                
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = EDGVConverterDialog()

        self.fPopulaBase()
        f= open(str(os.path.dirname(os.path.realpath(__file__)))+'//temp//'+"arq_selected.json","w+")
        self.dlg.cmbBaseOrigem.currentIndexChanged.connect(self.on_cmbBaseOrigem_change)
        self.dlg.cmbBaseDestino.currentIndexChanged.connect(self.on_cmbBaseDestino_change)
        
        self.dlg.btnAtributosDominio.clicked.connect(self.on_btnAtributosDominio_click)
        self.dlg.btnAtributosClasse.clicked.connect(self.on_btnAtributosClasse_click)
        self.dlg.btnSair.clicked.connect(self.on_btnSair_click)
        self.dlg.btnTesteConexao.clicked.connect(self.on_btnTesteConexao_click)
        
        self.dlg2.btnRelacionar.clicked.connect(self.on_btnRelacionar_click)
        self.dlg2.btnCancel.clicked.connect(self.on_btnCancel1_click)
        self.dlg2.btnRemover.clicked.connect(self.on_btnRemover_click)
        
        self.dlg3.btnRelacionar.clicked.connect(self.on_btnRelacionar2_click)
        self.dlg3.btnCancel.clicked.connect(self.on_btnCancel2_click)
        self.dlg.btnRun.clicked.connect(self.on_btnRun_click)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        f.close()
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
def fVerificaCaminho(tipo,arq):
    #pathPadrao= "C://Users//claud//AppData//Roaming//QGIS//QGIS3//profiles//default//python//plugins//edgv_converter - teste//temp"
    pathPadrao= os.path.dirname(os.path.realpath(__file__))+'//temp'
    if os.path.isdir(pathPadrao):
        pass
    else:
        os.mkdir(pathPadrao)
        os.mkdir(pathPadrao+'//LDOM')
        os.mkdir(pathPadrao+'//LISTA')
        
    if arq != "":
        if tipo=='LDOM':
            if os.path.isfile(pathPadrao+'//LDOM//'+str(arq)):
                return True
            else:
                return False
            #arqLST_classe_origem.JSON
        elif tipo == 'LISTA':
            if os.path.isfile(pathPadrao+'//LISTA//'+str(arq)):
                return True
            else:
                return False
def is_number(s):
    if s is None:
        pass
    try:
        float(s)
        return True
    except ValueError:
        pass
 
    try:
        import unicodedata
        unicodedata.numeric(s)
        return True
    except (TypeError, ValueError):
        pass
 
    return False

def fProcuraDicionario(arqJSON,tipo,colunaOrigem,valorOrigem):
    #global colunaOrigem
    
    loaded_json = arqJSON
    
    if tipo == "COLUNA_IDA":
        for x in loaded_json['Par_Colunas']:
        #print (x['valor'])
            if x['Coluna_Origem'] == colunaOrigem:
        #abre o jSON e procura o valor correspondente da coluna
                #print (x['Coluna_Destino'])
                a = x['Coluna_Destino']
                return a
    elif tipo == "COLUNA_VOLTA":
        for x in loaded_json['Par_Colunas']:
        #print (x['valor'])
            if x['Coluna_Destino'] == colunaOrigem:
        #abre o jSON e procura o valor correspondente da coluna
                #print (x['Coluna_Destino'])
                a = x['Coluna_Origem']
                return a
    
    if tipo == "LISTA_DOM":
        for y in loaded_json['Par_Colunas']:
        #print (x['valor'])
            if y['Coluna_Origem'] == colunaOrigem:
                if y['Valor_Origem'] == valorOrigem:
        #abre o jSON e procura o valor correspondente da coluna
                    #print (x['Valor_Destino'])
                    b = y['Valor_Destino']
                    return b
                else:
                    b = y['Valor_Origem']
                    return b
            else:
                b = y['Valor_Origem']
                return b
def fProcuraCorrespClasse(strClasseOrigem):
    a='%s'%str(strClasseOrigem)
    #print(a)
    path=os.path.dirname(os.path.realpath(__file__))+'\\temp\\LISTA\\arqLST_' +a+'.json'
    if fVerificaCaminho('LISTA',a)==True:
        with open(path, "r") as json_data1:
            json_data =  json.load(json_data1) 
            for p in json_data['Par_Colunas']:
                if p['Classe_Origem']==a:
                    b=p['Classe_Destino']
                    return b            
        var=''
        return var   
